---
title: 计算机的原码、反码和补码
date: 2020-01-08 22:17:50
tags:
    - 计算机原理
---

# 原码 反码 补码

### 机器数和真值

##### 机器数

 一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1 。

比如，十进制中的数` +3` ，计算机字长为8位，转换成二进制就是`00000011`。如果是 `-3` ，就是 `10000011` 。

那么，这里的 `00000011` 和 `10000011` 就是机器数。

##### 真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 `10000011`，其最高位`1`代表负，其真正数值是 `-3` 而不是形式值`131`（`10000011`转换成十进制等于`131`）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

因此`10000011`的真值为`-3`。



### 原码 反码 补码

##### 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

> [-1]<sub>原</sub> = 1000 0001
>
> [+1]<sub>原</sub> = 0000 0001

第一位是符号位。因为第一位是符号位, 所以8位二进制数的取值范围就是：

>  [1111 1111 , 0111 1111] 

即

> [-127, 127]



##### 反码

反码的表示方法是：

- 正数的反码是其本身

- 负数的反码是在其原码的基础上，符号位不变，其余各个位取反：

  > [+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub>
  >
  > [-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub>

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。



 ##### 补码

补码的表示方法是：

- 正数的补码就是其本身

- 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后加1（即在反码的基础上加1）

  >[+1] = [00000001]<sub>原</sub> = [00000001]<sub>反</sub> = [00000001]<sub>补</sub>
  >
  >[-1] = [10000001]<sub>原</sub> = [11111110]<sub>反</sub> = [11111111]<sub>补</sub>



##### 为什么需要反码和补码

 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减。 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单 。 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂 。 于是人们想出了将符号位也参与运算的方法 。

我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: `1 - 1 = 1 + (-1) = 0` , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了 。

对于计算`1-1=0`，首先来看原码：

> 1 - 1 = 1 + (-1) = [00000001]<sub>原</sub> + [10000001]<sub>原</sub> = [10000010]<sub>原</sub> = -2

如果用原码来进行计算，将符号位也参与计算，显然计算结果是错误的。

因此引入了反码：

> 1 - 1 = 1 + (-1) = [00000001]<sub>反</sub> + [111111110]<sub>反</sub>  = [11111111]<sub>反</sub> = -0

发现使用反码计算，结果的真值是正确的。但是也存在问题，再看下面一个例子：

> 0 + 0 = [00000000]<sub>反</sub> + [00000000]<sub>反</sub> = +0

对于结果`0`,可能会得到`-0`和`+0`两个不同的结果。

而补码的出现，解决了这个问题：

> 1 - 1 = [00000001]<sub>补</sub> + [11111111]<sub>补</sub> = [00000000]<sub>补</sub> = 0
>
> 0 + 0 = [00000000]<sub>补</sub> + [00000000]<sub>补</sub> = 0

可以看到，使用补码进行计算，将会只有一个`0`，而且可以用`10000000`来表示`-128`:

> -1 + -127 = [11111111]<sub>补</sub> + [10000001]<sub>补</sub> = [10000000]<sub>补</sub>

因此，对于一个8位的带符号数，如果使用补码来进行表示，则取值范围位`[-128, 127]`

而对于原码和反码，因为都存在两个`0`：

> +0 = [00000000]<sub>原</sub> = [00000000]<sub>反</sub>
>
> -0 = [10000000]<sub>原</sub> = [11111111]<sub>反</sub>

有效取值范围都只有`[-127, 127]`

使用补码，不仅解决了减法的问题，还修复了存在两个`0`的问题，使得负数的有效值可以多一位。

因此，计算机都是使用补码来表示正数，对于`n`位的整数，其有效范围为：

> [-2<sup>n-1</sup>, 2<sup>n-1</sup>-1]



##### 补码的本质

补码本质是用来构成一个环，以实现一个同余运算。 

假设8位的整数为例，我们计算的结果最终都是`2^8`的余数，这与符号位没有关系，也就是需要`mod 2^8`，也就是当计算结果超过8位时，高位会被舍弃，就是溢出。

比如：

> 1 + 255 = 256  = 0
>
> 1 - 1 = 0 

这其实是**同余**的概念：两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余，记作`a ≡ b (mod m)`

我们来看 255和-1：

> 255 mod 256 = 255 
>
> -1 mod 256 = 255

也就是 ` -1 ≡ 255 mod 256`

在一个环中，00000000<sub>b</sub>和11111111<sub>b</sub>连接，当00000000<sub>b</sub>向后走一步，就回到11111111<sub>b</sub>了。



同余加法：

> a ≡ b mod m
>
> c ≡ d mod m 
>
> a+c ≡ b+d mod m

所以有：

> 1 ≡ 1 mod 256
>
> -1 ≡ 255 mod 256
>
> 1-1 ≡ 1+255 mod 256

所以 1-1 = 1+255 = 0

对于255的二进制表示：

> 255 = 11111111<sub>b</sub>

因为 `-1≡255 mod 256`，在8位的带符号数中，我们可以用11111111<sub>b</sub>来表示`-1`，而这不正是`-1`的补码吗。



### 参考
- [原码、反码和补码详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html)